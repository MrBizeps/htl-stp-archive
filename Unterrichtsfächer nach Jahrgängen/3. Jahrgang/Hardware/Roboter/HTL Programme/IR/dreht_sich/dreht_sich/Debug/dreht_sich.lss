
dreht_sich.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000260  00000000  00000000  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .stab         000006cc  00000000  00000000  000002b4  2**2
                  CONTENTS, READONLY, DEBUGGING
  2 .stabstr      00000085  00000000  00000000  00000980  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_aranges 00000080  00000000  00000000  00000a08  2**3
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000004bc  00000000  00000000  00000a88  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 00000168  00000000  00000000  00000f44  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   0000035b  00000000  00000000  000010ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  000000cc  00000000  00000000  00001408  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    0000016e  00000000  00000000  000014d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    000000d6  00000000  00000000  00001642  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 56 00 	jmp	0xac	; 0xac <__ctors_end>
   4:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
   8:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
   c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  10:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  14:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  18:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  1c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  20:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  24:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  28:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  2c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  30:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  34:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  38:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  3c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  40:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  44:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  48:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  4c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  50:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  54:	0c 94 cb 00 	jmp	0x196	; 0x196 <__vector_21>
  58:	0c 94 d6 00 	jmp	0x1ac	; 0x1ac <__vector_22>
  5c:	0c 94 e1 00 	jmp	0x1c2	; 0x1c2 <__vector_23>
  60:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  64:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  68:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  6c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  70:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  74:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  78:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  7c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  80:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  84:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  88:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  8c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  90:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  94:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  98:	0c 94 75 00 	jmp	0xea	; 0xea <__vector_38>
  9c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  a0:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  a4:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  a8:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>

000000ac <__ctors_end>:
  ac:	11 24       	eor	r1, r1
  ae:	1f be       	out	0x3f, r1	; 63
  b0:	cf ef       	ldi	r28, 0xFF	; 255
  b2:	da e0       	ldi	r29, 0x0A	; 10
  b4:	de bf       	out	0x3e, r29	; 62
  b6:	cd bf       	out	0x3d, r28	; 61

000000b8 <__do_copy_data>:
  b8:	11 e0       	ldi	r17, 0x01	; 1
  ba:	a0 e0       	ldi	r26, 0x00	; 0
  bc:	b1 e0       	ldi	r27, 0x01	; 1
  be:	e0 e6       	ldi	r30, 0x60	; 96
  c0:	f2 e0       	ldi	r31, 0x02	; 2
  c2:	02 c0       	rjmp	.+4      	; 0xc8 <__do_copy_data+0x10>
  c4:	05 90       	lpm	r0, Z+
  c6:	0d 92       	st	X+, r0
  c8:	a0 30       	cpi	r26, 0x00	; 0
  ca:	b1 07       	cpc	r27, r17
  cc:	d9 f7       	brne	.-10     	; 0xc4 <__do_copy_data+0xc>

000000ce <__do_clear_bss>:
  ce:	11 e0       	ldi	r17, 0x01	; 1
  d0:	a0 e0       	ldi	r26, 0x00	; 0
  d2:	b1 e0       	ldi	r27, 0x01	; 1
  d4:	01 c0       	rjmp	.+2      	; 0xd8 <.do_clear_bss_start>

000000d6 <.do_clear_bss_loop>:
  d6:	1d 92       	st	X+, r1

000000d8 <.do_clear_bss_start>:
  d8:	a0 30       	cpi	r26, 0x00	; 0
  da:	b1 07       	cpc	r27, r17
  dc:	e1 f7       	brne	.-8      	; 0xd6 <.do_clear_bss_loop>
  de:	0e 94 f5 00 	call	0x1ea	; 0x1ea <main>
  e2:	0c 94 2e 01 	jmp	0x25c	; 0x25c <_exit>

000000e6 <__bad_interrupt>:
  e6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ea <__vector_38>:
#include <util/delay.h>



ISR (TIMER4_COMPA_vect)						//IR-Empfänger TSOP1736
{	
  ea:	1f 92       	push	r1
  ec:	0f 92       	push	r0
  ee:	0f b6       	in	r0, 0x3f	; 63
  f0:	0f 92       	push	r0
  f2:	11 24       	eor	r1, r1
  f4:	8f 93       	push	r24
  f6:	9f 93       	push	r25
	TCNT4 = 0;
  f8:	10 92 bf 00 	sts	0x00BF, r1
  fc:	10 92 be 00 	sts	0x00BE, r1
	PORTC = PORTC^(1<<PORTC6);				//36 kHz Signal
 100:	98 b1       	in	r25, 0x08	; 8
 102:	80 e4       	ldi	r24, 0x40	; 64
 104:	89 27       	eor	r24, r25
 106:	88 b9       	out	0x08, r24	; 8
}
 108:	9f 91       	pop	r25
 10a:	8f 91       	pop	r24
 10c:	0f 90       	pop	r0
 10e:	0f be       	out	0x3f, r0	; 63
 110:	0f 90       	pop	r0
 112:	1f 90       	pop	r1
 114:	18 95       	reti

00000116 <init_IR>:

void init_IR (void)
{
	DDRB = DDRB|(1<<DDB0);					//PB0 (IR-right) als Output
 116:	20 9a       	sbi	0x04, 0	; 4
	DDRD = DDRD|(1<<DDD4);					//PD4 (IR-left) als Output
 118:	54 9a       	sbi	0x0a, 4	; 10
	DDRC = DDRC|(1<<DDC6);					//PC6 (IR-36kHz) als Output
 11a:	3e 9a       	sbi	0x07, 6	; 7
	DDRD = DDRD&~(1<<DDD5);					//PD5 (IR-Empfänger) als Input
 11c:	55 98       	cbi	0x0a, 5	; 10
	PORTD = PORTD|(1<<PORTD5);				//PD5 int. Pull Up Widerstand ein
 11e:	5d 9a       	sbi	0x0b, 5	; 11
	DDRB = DDRB|(1<<DDB3);					//PB3 left Back LED als Output
 120:	23 9a       	sbi	0x04, 3	; 4
	DDRD = DDRD|(1<<DDD2);					//PD2 right Front LED als Output
 122:	52 9a       	sbi	0x0a, 2	; 10
	PORTB = PORTB|(1<<PORTB3);				//alle Front- und Back-LEDs aus
 124:	2b 9a       	sbi	0x05, 3	; 5
	PORTD = PORTD|(1<<PORTD2);
 126:	5a 9a       	sbi	0x0b, 2	; 11
	
 	TIMSK4 = TIMSK4 | (1<<OCIE4A);			//Timer_4 CompareA Interrupt freigeben
 128:	e2 e7       	ldi	r30, 0x72	; 114
 12a:	f0 e0       	ldi	r31, 0x00	; 0
 12c:	80 81       	ld	r24, Z
 12e:	80 64       	ori	r24, 0x40	; 64
 130:	80 83       	st	Z, r24
	OCR4A = 82;								//Endwert für 1/2* 1/36kHz = 13,89µs (111*125ns=13,875µs), 82 pass t lt. Messung
 132:	82 e5       	ldi	r24, 0x52	; 82
 134:	80 93 cf 00 	sts	0x00CF, r24
	TCCR4B = TCCR4B|(1<<CS40);				//:1 Teiler => dt=1/8MHz=125ns
 138:	e1 ec       	ldi	r30, 0xC1	; 193
 13a:	f0 e0       	ldi	r31, 0x00	; 0
 13c:	80 81       	ld	r24, Z
 13e:	81 60       	ori	r24, 0x01	; 1
 140:	80 83       	st	Z, r24
	sei();
 142:	78 94       	sei
}
 144:	08 95       	ret

00000146 <init_Motoren>:
	 
void init_Motoren (void)
{
	CLKPR = 0x80;							//Ändern des internen CLK-Prescalers
 146:	e1 e6       	ldi	r30, 0x61	; 97
 148:	f0 e0       	ldi	r31, 0x00	; 0
 14a:	80 e8       	ldi	r24, 0x80	; 128
 14c:	80 83       	st	Z, r24
	CLKPR = 0x01;							//16 Mhz :2 = 8 MHz 
 14e:	81 e0       	ldi	r24, 0x01	; 1
 150:	80 83       	st	Z, r24

/////////// Ports /////////////////
	DDRB = DDRB | (1<<DDB6);				//PB6 als Ausgang (normaler IO-Pin), linkes Rad
 152:	26 9a       	sbi	0x04, 6	; 4
	DDRD = DDRD | (1<<DDD0);				//PD0 als Ausgang (OC0B), rechtes Rad
 154:	50 9a       	sbi	0x0a, 0	; 10
	DDRF = DDRF | (1<<DDF5);				//PF5 als Ausgang (Motor Driver Enable)
 156:	85 9a       	sbi	0x10, 5	; 16

/////////// Timer 0 Fast PWM /////////////////	
	TCCR0A = TCCR0A | (1<<WGM00);
 158:	84 b5       	in	r24, 0x24	; 36
 15a:	81 60       	ori	r24, 0x01	; 1
 15c:	84 bd       	out	0x24, r24	; 36
	TCCR0A = TCCR0A | (1<<WGM01);
 15e:	84 b5       	in	r24, 0x24	; 36
 160:	82 60       	ori	r24, 0x02	; 2
 162:	84 bd       	out	0x24, r24	; 36
	TCCR0B = TCCR0B &~(1<<WGM02);			//WGM2:0=3		Fast PWM
 164:	85 b5       	in	r24, 0x25	; 37
 166:	87 7f       	andi	r24, 0xF7	; 247
 168:	85 bd       	out	0x25, r24	; 37

	TCCR0A = TCCR0A &~(1<<COM0A0);
 16a:	84 b5       	in	r24, 0x24	; 36
 16c:	8f 7b       	andi	r24, 0xBF	; 191
 16e:	84 bd       	out	0x24, r24	; 36
	TCCR0A = TCCR0A | (1<<COM0A1);			//COM1:2=2      Non Inverting, für links (PB6/normaler IO-Pin)
 170:	84 b5       	in	r24, 0x24	; 36
 172:	80 68       	ori	r24, 0x80	; 128
 174:	84 bd       	out	0x24, r24	; 36
	
	TCCR0A = TCCR0A &~(1<<COM0B0);
 176:	84 b5       	in	r24, 0x24	; 36
 178:	8f 7e       	andi	r24, 0xEF	; 239
 17a:	84 bd       	out	0x24, r24	; 36
	TCCR0A = TCCR0A | (1<<COM0B1);			//COM1:2=2      Non Inverting, für rechts (PD0/OC0B)
 17c:	84 b5       	in	r24, 0x24	; 36
 17e:	80 62       	ori	r24, 0x20	; 32
 180:	84 bd       	out	0x24, r24	; 36
	
	TCCR0B = TCCR0B|(1<<CS01);				//:8 Teiler, startet die PWM, fPWM_Interrupt = fquarz/(Teiler*256) = 3.9 kHz 
 182:	85 b5       	in	r24, 0x25	; 37
 184:	82 60       	ori	r24, 0x02	; 2
 186:	85 bd       	out	0x25, r24	; 37
	
	TIMSK0 = TIMSK0|(1<<OCIE0A)|(1<<OCIE0B)|(1<<TOIE0);//Interrupts freigeben
 188:	ee e6       	ldi	r30, 0x6E	; 110
 18a:	f0 e0       	ldi	r31, 0x00	; 0
 18c:	80 81       	ld	r24, Z
 18e:	87 60       	ori	r24, 0x07	; 7
 190:	80 83       	st	Z, r24
	sei();									
 192:	78 94       	sei
}
 194:	08 95       	ret

00000196 <__vector_21>:

// Interrupts für Fast PWM auf beliebigen Portpins
ISR(TIMER0_COMPA_vect)
{
 196:	1f 92       	push	r1
 198:	0f 92       	push	r0
 19a:	0f b6       	in	r0, 0x3f	; 63
 19c:	0f 92       	push	r0
 19e:	11 24       	eor	r1, r1
	PORTB = PORTB &~ (1<<PORTB6);			//Motor links (PB6)
 1a0:	2e 98       	cbi	0x05, 6	; 5
}
 1a2:	0f 90       	pop	r0
 1a4:	0f be       	out	0x3f, r0	; 63
 1a6:	0f 90       	pop	r0
 1a8:	1f 90       	pop	r1
 1aa:	18 95       	reti

000001ac <__vector_22>:

ISR(TIMER0_COMPB_vect)
{
 1ac:	1f 92       	push	r1
 1ae:	0f 92       	push	r0
 1b0:	0f b6       	in	r0, 0x3f	; 63
 1b2:	0f 92       	push	r0
 1b4:	11 24       	eor	r1, r1
	PORTD = PORTD &~ (1<<PORTD0);			//Motor rechts (PD0/OC0B)
 1b6:	58 98       	cbi	0x0b, 0	; 11
}   
 1b8:	0f 90       	pop	r0
 1ba:	0f be       	out	0x3f, r0	; 63
 1bc:	0f 90       	pop	r0
 1be:	1f 90       	pop	r1
 1c0:	18 95       	reti

000001c2 <__vector_23>:

ISR(TIMER0_OVF_vect)
{
 1c2:	1f 92       	push	r1
 1c4:	0f 92       	push	r0
 1c6:	0f b6       	in	r0, 0x3f	; 63
 1c8:	0f 92       	push	r0
 1ca:	11 24       	eor	r1, r1
	PORTB = PORTB | (1<<PORTB6);			//Motor links
 1cc:	2e 9a       	sbi	0x05, 6	; 5
	PORTD = PORTD | (1<<PORTD0);			//Motor rechts
 1ce:	58 9a       	sbi	0x0b, 0	; 11
}
 1d0:	0f 90       	pop	r0
 1d2:	0f be       	out	0x3f, r0	; 63
 1d4:	0f 90       	pop	r0
 1d6:	1f 90       	pop	r1
 1d8:	18 95       	reti

000001da <drive>:


	 
void drive (unsigned char speed_left, unsigned char speed_right, unsigned char start_stop)
{
	OCR0B = speed_right;					//Geschwindigkeit links (0xFF vollgas vor, 0x00 vollgas retout, 0x80 stopp)
 1da:	68 bd       	out	0x28, r22	; 40
	OCR0A = speed_left;						//Geschwindigkeit rechts (0xFF vollgas vor, 0x00 vollgas retout, 0x80 stopp)
 1dc:	87 bd       	out	0x27, r24	; 39

	if (start_stop == 1)
 1de:	41 30       	cpi	r20, 0x01	; 1
 1e0:	11 f4       	brne	.+4      	; 0x1e6 <drive+0xc>
	{PORTF = PORTF | (1<<PORTF5);}			//Motor Driver Enable => Start
 1e2:	8d 9a       	sbi	0x11, 5	; 17
 1e4:	08 95       	ret
	else
	{PORTF = PORTF &~(1<<PORTF5);}			//Motor Driver Disable => Stopp
 1e6:	8d 98       	cbi	0x11, 5	; 17
 1e8:	08 95       	ret

000001ea <main>:



int main (void)
{
	MCUCR = MCUCR|(1<<JTD);				//JTAG disable
 1ea:	85 b7       	in	r24, 0x35	; 53
 1ec:	80 68       	ori	r24, 0x80	; 128
 1ee:	85 bf       	out	0x35, r24	; 53
	MCUCR = MCUCR|(1<<JTD);
 1f0:	85 b7       	in	r24, 0x35	; 53
 1f2:	80 68       	ori	r24, 0x80	; 128
 1f4:	85 bf       	out	0x35, r24	; 53

	init_Motoren();
 1f6:	0e 94 a3 00 	call	0x146	; 0x146 <init_Motoren>
	init_IR();
 1fa:	0e 94 8b 00 	call	0x116	; 0x116 <init_IR>
	
	while(1)
		{
			PORTD = PORTD&~(1<<PORTD4);							//IR-left ON
 1fe:	5c 98       	cbi	0x0b, 4	; 11
			PORTB = PORTB|(1<<PORTB0);							//IR-right OFF
 200:	28 9a       	sbi	0x05, 0	; 5
			if (PIND&(1<<PIND5)) 
 202:	4d 9b       	sbis	0x09, 5	; 9
 204:	07 c0       	rjmp	.+14     	; 0x214 <main+0x2a>
				{
					PORTB = PORTB&~(1<<PORTB2);					//LED left Back EIN
 206:	2a 98       	cbi	0x05, 2	; 5
					drive(0x80,0x80,0);							//Motoren STOP	
 208:	80 e8       	ldi	r24, 0x80	; 128
 20a:	60 e8       	ldi	r22, 0x80	; 128
 20c:	40 e0       	ldi	r20, 0x00	; 0
 20e:	0e 94 ed 00 	call	0x1da	; 0x1da <drive>
 212:	06 c0       	rjmp	.+12     	; 0x220 <main+0x36>
				}	
			else 
				{
					PORTB = PORTB|(1<<PORTB2);					//LED left Back AUS
 214:	2a 9a       	sbi	0x05, 2	; 5
					drive(0x05,0xFF,1);							//drehen
 216:	85 e0       	ldi	r24, 0x05	; 5
 218:	6f ef       	ldi	r22, 0xFF	; 255
 21a:	41 e0       	ldi	r20, 0x01	; 1
 21c:	0e 94 ed 00 	call	0x1da	; 0x1da <drive>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 220:	8f e1       	ldi	r24, 0x1F	; 31
 222:	9e e4       	ldi	r25, 0x4E	; 78
 224:	01 97       	sbiw	r24, 0x01	; 1
 226:	f1 f7       	brne	.-4      	; 0x224 <main+0x3a>
 228:	00 c0       	rjmp	.+0      	; 0x22a <main+0x40>
 22a:	00 00       	nop
				}					
			_delay_ms(10);
					
			PORTD = PORTD|(1<<PORTD4);							//IR-left OFF
 22c:	5c 9a       	sbi	0x0b, 4	; 11
			PORTB = PORTB&~(1<<PORTB0);							//IR-right ON
 22e:	28 98       	cbi	0x05, 0	; 5
			if (PIND&(1<<PIND5)) 
 230:	4d 9b       	sbis	0x09, 5	; 9
 232:	07 c0       	rjmp	.+14     	; 0x242 <main+0x58>
				{
					PORTD = PORTD&~(1<<PORTD2);					//LED right front EIN
 234:	5a 98       	cbi	0x0b, 2	; 11
					drive(0x80,0x80,0);							//Motoren STOP	
 236:	80 e8       	ldi	r24, 0x80	; 128
 238:	60 e8       	ldi	r22, 0x80	; 128
 23a:	40 e0       	ldi	r20, 0x00	; 0
 23c:	0e 94 ed 00 	call	0x1da	; 0x1da <drive>
 240:	06 c0       	rjmp	.+12     	; 0x24e <main+0x64>
				}	
			else 
				{
					PORTD = PORTD|(1<<PORTD2);					//LED right front AUS
 242:	5a 9a       	sbi	0x0b, 2	; 11
					drive(0xFF,0x05,1);							//drehen
 244:	8f ef       	ldi	r24, 0xFF	; 255
 246:	65 e0       	ldi	r22, 0x05	; 5
 248:	41 e0       	ldi	r20, 0x01	; 1
 24a:	0e 94 ed 00 	call	0x1da	; 0x1da <drive>
 24e:	8f e1       	ldi	r24, 0x1F	; 31
 250:	9e e4       	ldi	r25, 0x4E	; 78
 252:	01 97       	sbiw	r24, 0x01	; 1
 254:	f1 f7       	brne	.-4      	; 0x252 <main+0x68>
 256:	00 c0       	rjmp	.+0      	; 0x258 <main+0x6e>
 258:	00 00       	nop
 25a:	d1 cf       	rjmp	.-94     	; 0x1fe <main+0x14>

0000025c <_exit>:
 25c:	f8 94       	cli

0000025e <__stop_program>:
 25e:	ff cf       	rjmp	.-2      	; 0x25e <__stop_program>
